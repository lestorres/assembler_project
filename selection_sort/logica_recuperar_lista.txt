section .data
    leer_datos db "Marta González Jiménez nota: 70", 10, "Javier López Fernández nota: 65", 10, "César Ramos Sánchez nota: 88", 10, "Raúl Pérez Ruiz nota: 69", 10, "Sonia Gómez Fernández nota: 91", 10, "Carolina López Sánchez nota: 83", 10, "Sergio Rodríguez Pérez nota: 76", 10, "Paula Sánchez Hernández nota: 19", 10, "Rubén García Martínez nota: 90", 10, "Clara Ruiz González nota: 80", 10, "Maria Torres Fernández nota: 91", 10, "José Luis Rodríguez Díaz nota: 72", 10
    leer_datos_len equ $ - leer_datos
    nota_buscada db "nota: "        ; Subcadena que buscamos para encontrar las notas

section .bss
    estudiantes resb 1024            ; Reservamos espacio para almacenar las líneas de estudiantes
    notas resb 12                   ; Reservamos espacio para almacenar las notas (enteros)
    idx resb 1                      ; Índice para las líneas procesadas
    student_struct resb 2048       ; Estructura para almacenar estudiantes y sus notas
    temp_line resb 128             ; Buffer temporal para almacenar una línea (nombre + nota)
    num_buff resb 4                ; Buffer para almacenar la nota como string
    line_offset resb 4             ; Puntero temporal para iterar en el arreglo de estudiantes

section .text
    global _start

_start:
    ; Empezamos con el buffer de datos
    mov rsi, leer_datos            ; Dirección del buffer con los datos
    mov rbx, student_struct        ; Puntero al buffer donde almacenamos los estudiantes
    xor rdi, rdi                   ; Índice de las líneas procesadas (estudiantes)

extraer_nota_y_estudiante:
    ; Buscar un salto de línea o fin de cadena para determinar el fin de una línea
    mov al, byte [rsi]             ; Cargar el primer carácter de la línea
    cmp al, 10                     ; Comparamos con el salto de línea (0xA)
    je procesar_linea              ; Si es un salto de línea, procesamos la línea
    
    ; Si no es un salto de línea, seguimos leyendo el siguiente byte
    inc rsi
    jmp extraer_nota_y_estudiante ; Continuamos buscando

procesar_linea:
    ; Aquí procesamos la línea (nombre + nota)
    ; Primero, buscar la palabra "nota: "
    mov rbx, nota_buscada         ; Dirección de la subcadena "nota: "
    
    ; Buscar "nota: " en la línea
buscar_nota:
    mov al, [rsi]                 ; Cargar el siguiente byte de la línea
    mov bl, [rbx]                 ; Cargar el siguiente byte de "nota: "
    cmp al, bl                    ; Comparar
    jne no_encontrado             ; Si no coinciden, saltamos

    inc rsi                       ; Avanzamos el puntero de la línea
    inc rbx                       ; Avanzamos en la subcadena "nota: "
    test bl, bl                   ; Si llegamos al final de "nota:", saltamos
    jnz buscar_nota               ; Si no hemos terminado de buscar "nota:", seguimos

    ; Ahora que hemos encontrado "nota:", leer la nota
    call leer_numero              ; Llamar para leer la nota (número)

    ; Después de procesar la línea, incrementamos el índice de líneas procesadas
    inc byte [idx]                ; Incrementar el índice de estudiantes

    ; Verificar si hemos llegado al final de	 los datos (EOF) o si hay más datos
    mov al, byte [rsi]            ; Cargar el siguiente byte
    cmp al, 0                     ; Comprobar si es fin de cadena (EOF)
    je fin_proceso                ; Si es 0, terminamos el proceso

    ; Si no hemos llegado al final, seguimos leyendo más líneas
    jmp extraer_nota_y_estudiante

fin_proceso:
    ; En este punto, ya hemos procesado todas las líneas
    ; Aquí podemos ordenar las líneas si es necesario
    ; Llamamos a Selection Sort para ordenar por las notas (esto debe implementarse)

    ; Finalizamos el programa
    mov rax, 60                   ; Llamada a exit
    xor rdi, rdi                  ; Código de salida 0
    syscall

; Función para leer la nota (número)
leer_numero:
    xor rcx, rcx                  ; Limpiamos rcx, que usaremos como índice
leer_numero_loop:
    mov al, [rsi + rcx]           ; Cargar el siguiente carácter de la nota
    cmp al, 10                    ; Verificamos si es un salto de línea (fin de número)
    je fin_numero                 ; Si encontramos un salto de línea, terminamos
    mov [num_buff + rcx], al      ; Almacenamos el carácter en el buffer
    inc rcx                       ; Aumentamos el índice
    jmp leer_numero_loop          ; Volver a leer el siguiente carácter

fin_numero:
    ; Ahora tenemos la nota en num_buff como cadena
    ; Podemos convertir la cadena a número (si es necesario)
    ret
,,,,,,,,,,,,,,,,

;-------------Ordenamiento--------------
ordenamiento:
    	print msg_lista_orden_open    

;Verificar si el ordenamiento en numerico o alfabetico(PROXIMAMENTE) 



; Se ordenará en base  a las notas de los estudiantes
ordenamiento_numerico:
;Recuperar datos
    	mov rsi, leer_datos    	; Dirección del buffer
    	mov rdx, student_struct ; Puntero a la estructura 
	mov rdi, 0		; indice lineas procesadas
 
 
extraer_linea:
	;leer hasta encontrar un salto de linea 0x0A
	mov al , byte[rsi]	; carga un byte
	cmp al , 0x0A		; es un salto de linea
	je procesar_linea	;Si es salto, procesa la linea anterior al salto

	inc rsi 		; Si no, sigue leyendo
	jmp extraer_linea

procesar_linea:
	mov rax, 0		;vaciar rax
	mov rbx, nota_buscada   ;carga la variable "nota: "

buscar_nota:
	;busqueda de "nota: " 
	mov al, byte[rsi]    ;carga el primer byte de la linea en rsi
	mov bl, byte[rbx]    ;carga el primer byte de "nota: "en rbx
	inc byte[idx]	     ; Cuenta cuantos bytes hay hasta "nota: "
	cmp al, bl
	jne nota_no_encontrada	;No coinciden

	inc rsi ; se avanza en el texto 
	inc rbx ; se avanza en "nota: "
	test bl,bl ; hasta que termine el "nota: "
	jnz buscar_nota
	
	; A este punto se encontro el "nota: "
	mov rsi, rsi	;esta justo a la al final de "nota: "<- acá 
	call leer_numero_nota ;La nota queda almacenada en nota_str
	
	inc byte[lineas_count] ; cuenta la linea(indica cuantos estudiante))

;copiar el estudiante al struct
	mov rbx, student_struct ;Direccion del struct
	mov rdi, rbx		; carga la dir. del struct a rdi

	;carga la nota al struct
	mov rbx, nota_str	;Carga la dir. de la nota
	mov rdi, rbx		; Guarda la nota en el struct


	; copiar la linea
	mov rsi, leer_datos
	call copiar_linea

	inc rsi ; se avanza en el texto



copiar_linea:
	;ejemplo de uso de rep movsb
	;mov cx,5 	; numero de bytes a mover
	;mov si, source ; dir. origen
	;movdi, dest    ; dir. destino
	;rep movsb 	; mueve CX bytes de "source" a "dest"

	mov rcx , idx ; Carga la longitud del nombre antes de "nota: "
	;RSI de origen, es leer datos
	;RDI de destino, es el struct
	rep movsb; copia idx bytes de rsi a rdi
	ret



leer_numero_nota:
	xor rcx, rcx; limpiar el contador

leer_numero_loop:
	mov al, [rsi+rcx]	;cargar el siguiente caracter en ali
	cmp al, 0x0A  		; es salto de linea?
	je fin_numero_nota
	mov [nota_str + rcx], al ; guarda la "nota" en nota_str
	inc rcx
	jmp leer_numero_loop
	
fin_numero_nota:
	ret

	
nota_no_encontrada:
	;leer hasta encontrar un salto de linea 0x0A
	;mov al , byte[rsi]	; YA SE HIZO EN el paso anterior
	cmp al , 0x0A		; es un salto de linea?
	je extraer_linea	;Si es salto, extraiga otra linea

	inc rsi 		; Si no, sigue leyendo
	jmp buscar_nota



; 2. Extraer las notas (se asume que las notas están al final de cada línea)
; Aquí se implementa la lógica para extraer las notas
; (esto es un ejemplo simplificado)

selection_sort_notas:
; Algoritmo Selection Sort para ordenar las notas















